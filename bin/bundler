#!/usr/bin/env php
<?php

require(__DIR__ . '/../vendor/autoload.php');

use Filicious\File;
use Filicious\Filesystem;
use Filicious\Local\LocalAdapter;

class bundler
{
	public static function run()
	{
		$fs = new Filesystem(
			new LocalAdapter(
				dirname(__DIR__)
			)
		);

		$interfaces = array();
		$classes    = array();
		$others     = array();

		// add src files
		$srcDir   = $fs->getFile('src');
		$iterator = $srcDir->getIterator(
			File::LIST_RECURSIVE,
			function ($file) {
				return strpos($file->getPathname(), '/Console/') !== false;
			}
		);
		self::addFiles($iterator, $interfaces, $classes, $others);

		// add some vendor files
		self::addDirectories($fs, 'vendor/bit3/remote-objects/src');
		self::addDirectories($fs, 'vendor/filicious/filicious/src');
		self::addDirectories($fs, 'vendor/monolog/monolog/src');

		// sort files
		$interfaces = self::sortFiles($interfaces);
		$classes    = self::sortFiles($classes);

		// create buffer
		$buffer = fopen('php://memory', 'wb+');
		fwrite($buffer, <<<EOF
<?php

/**
 * This file contains a bunch of files, bundled into one single file.
 *
 * See http://contao-cloud.com for more details about this script
 * and all scripts used to generate this bundle.
 */


EOF
		);

		// add files to buffer
		foreach ($interfaces as $interface) {
			self::addFile($interface->file, $buffer);
		}
		foreach ($classes as $class) {
			self::addFile($class->file, $buffer);
		}

		// add execution script to buffer
		$script = $fs->getFile('scripts/connector.php');
		self::addFile($script, $buffer);

		// output the bundled script
		fseek($buffer, 0);
		fpassthru($buffer);
		fclose($buffer);
	}

	public static function normaliseClassName($className)
	{
		$parts = explode('\\', $className);
		$parts = array_filter($parts);
		return implode('\\', $parts);
	}

	protected static function addDirectories(Filesystem $fs, $path)
	{
		$dir = $fs->getFile($path);
		$iterator     = $dir->getIterator(
			File::LIST_RECURSIVE
		);
		self::addFiles($iterator, $interfaces, $classes, $others);
	}

	/**
	 * @param array    $files
	 * @param resource $buffer
	 */
	protected static function addFiles(Traversable $iterator, &$interfaces, &$classes, &$others)
	{
		/** @var File $file */
		foreach ($iterator as $file) {
			$content = $file->getContents();

			if (preg_match(
				'#((?:abstract\s+)?class|interface)(.+)(?:extends(.*))?(?:implements(.*))?\{#sU',
				$content,
				$match
			)
			) {
				$name    = trim($match[2]);
				$extends = isset($match[3])
					? array_filter(
						array_map(
							'trim',
							explode(',', $match[3])
						)
					)
					: array();

				$isInterface = $match[1] == 'interface';
				$isAbstract  = $match[1] == 'abstract class';

				if (preg_match('#namespace ([^;]+);#', $content, $match)) {
					$namespace = static::normaliseClassName($match[1]);
					$name      = $namespace . '\\' . $name;
				}
				else {
					$namespace = '';
				}

				$uses = array();
				if (preg_match_all('#\\n\\s*use\s+([\w\\\\]+)(?:\s+as\s+([^;]))?#i', $content, $match, PREG_SET_ORDER)) {
					foreach ($match as $use) {
						$useClass = static::normaliseClassName($use[1]);
						$useName = static::normaliseClassName(
							isset($use[2])
								? trim($use[2])
								: preg_replace('#^.*\\\\(.*)$#U', '$1', $use[1])
						);

						$uses[$useName] = $useClass;
					}
				}

				foreach ($extends as $k => $v) {
					if (isset($uses[$v])) {
						$extends[$k] = static::normaliseClassName($uses[$v]);
					}
					else if ($namespace && $v[0] !== '\\') {
						$extends[$k] = static::normaliseClassName($namespace . '\\' . $v);
					}
					else {
						$extends[$k] = static::normaliseClassName($v);
					}
				}

				$item = (object) array(
					'namespace'   => $namespace,
					'name'        => $name,
					'file'        => $file,
					'extends'     => $extends,
					'isInterface' => $isInterface,
					'isAbstract'  => $isAbstract
				);

				if ($isInterface) {
					$interfaces[$item->name] = $item;
				}
				else {
					$classes[$item->name] = $item;
				}
			}
			else {
				$others[] = $file;
			}
		}
	}

	protected static function sortFiles(array $classes)
	{
		$result = array();

		while (count($classes)) {
			$class = array_shift($classes);

			if (count($class->extends)) {
				foreach ($class->extends as $extend) {
					// skip dependency, because this is not a vendor class
					if (!isset($classes[$extend])) {
						continue;
					}

					// skip class and add later, because this dependency is not added yet
					if (!isset($result[$extend])) {
						$classes[$class->name] = $class;
						continue 2;
					}
				}
			}

			$result[$class->name] = $class;
		}

		return $result;
	}

	/**
	 * @param array    $files
	 * @param resource $buffer
	 */
	protected static function addFile(File $file, $buffer)
	{
		if ($file->isFile()) {
			$content = $file->getContents();

			// remove php tags
			$content = str_replace(
				array('<?php', '?>'),
				'',
				$content
			);

			$content = trim($content);

			// encapsulate namespace into {} block
			if (preg_match('#(namespace [^;]+);#', $content)) {
				$content = preg_replace(
					'#(namespace [^;]+);#',
					'$1 {',
					$content
				);
				$content .= "\n}\n";
			}

			fwrite($buffer, "\n");
			fwrite($buffer, '// source ' . $file->getPathname() . "\n\n");
			fwrite($buffer, $content . "\n");
		}
	}
}

bundler::run();
